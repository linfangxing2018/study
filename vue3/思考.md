## 思考

1. Composition API 和 <script setup> 虽然能提高开发效率，但是带来的一些新的语法，比如 ref 返回的数据就需要修改 value 属性；
   响应式和生命周期也需要 import 后才能使用等等，很多人也在社区批评这是 Vue 造的“方言” ，那你怎么看呢？
 
 Options API vs Composition API
        字面上, 选项 API 与 组合 API，细品, 这反映了设计面向的改变：
        1. 选项，谁的选项，关键在“谁”。谁？组件。也是 Vue2.x 的设计基础。组件有什么，
           有状态，有改变状态的方法，有生命周期，还有组件和组件之间的关系。这种情况
           下，“数据”要接受一定的“规矩”，“什么时候能做什么事”，“什么时候有什么表现”；
           这个状态下，开发模式像是“被动接受”。

        2. 组合，什么组合，关键在“什么”。什么？数据。数据的组合。Vue3.x 设计重点变了，数
           据变绝对的C了，现在去组件里串门，不用“守规矩”了，只需要说“我在 onMounted 的时
           候要这样这样，你看着办”，真只能的以“数据”为中心，没人能管得了了，想去哪就去哪，
           自然就灵活了

        至于这些是怎么做到由“被动接受”到“主动告知”的，实现这部分内容，我很期待。

  ✿ 模板语法更好用
        <script setup> 像是“语法糖”，很甜；<style>里能用 v-bind，以后开发可以
        少用“黑科技”了，双手点赞。

  ✿ 至于思考题
        Vue 本来就属于 DSL，语法方面各有偏好，见仁见智；响应式和生命周期需要 import，个
        人认为就代表了从之前的“被动主动”转向“主动告知”，这样设计更加灵活。从此一条主线在
        ”数据"，以后查 bug 顺着这条 "线" 应该更加容易了。

## 思考
2. 为什么需要响应式？
         随着页面应用的不断复杂，需要关注和管理的状态越来越多，之前靠被动的，分散的管
         理状态不现实也易出错。为了满足这个需求，出现了许多方案，其中 Vue 提出的或主打
         的解决方案的就是响应式。

      1. 怎么实现响应式？
         响应式主要解决的问题是怎么让在“语言层面上分散的独立数据”在“业务层面”上产生“联
         系或互为因果”的关系。这咋么办呢？怎么产生“联系”呢？简单，“你发生变化的时候告
         诉我一声，我应声而动”，所谓响应式我个人理解就是“你响我应”。

         但是这种需求在语言上不是“普遍需求”，属于“特殊需求”，怎么解决？这里就引入了“代
         理模式”这种设计模式。在语言层面我给你一种模式可以满足你的需求，ES5 的时代，是
         defineProperty 等，ES6 就是 Proxy。

         至于 ES6 的 Proxy 在性能或是各方面要优于 defineProperty 还是因为 Proxy 在更底
         层优化或重新实现，使用的表现“一样”，但“地基”不一样，性能各方面自然是不一样。
         正因为是“地基”的不同，Proxy 就还存在兼容性的问题, 加上业务场景的不同，
         defineProperty 还是有应用的场景，至于文中说的 Vue 3 的 ref 是用 “getter
         setter” 实现的，我的认识是，一个是“初始化”时的行为，一个是“改变行为”。

      2. useXXX 为什么会这么灵活？
         像之前的 Composition API 我理解的是 Vue 的组织单位由 “组件” 变成 “数据” 了，
         现在组件在引入 useXXX，关注点在 XXX，至于 XXX 跟什么有联系，那是你的事情，在
         你自己的 useXXX 里去实现。

         本节提到的 React Hooks 也有异曲同工的意思，Hooks 直接翻译成什么？“钩子”，用来
         做什么？“钩东西”，钩什么？那先说下这个东西出来之前有什么。

         React Hooks 出来之前 React 主要构建 App 还是用 Class Component，当然也有
         functional component，这俩区别就在于 class 有状态，functional 比较“纯粹”没有
         状态。这样复用成问题，得用什么高阶组件之类的方式。然后，在某一时刻，同样的问
         题出现了，React 复用组件的也是以带状态的 Class 组件为主，“复杂”了，不纯粹。

         应用越大，这种模式开发或维护越复杂。然后 Hooks 出现了，现在 React 都用
         “functional” 组件，但是有“状态”的，状态哪里来的 “Hook” 过来的，钩过来的。
         组件“不负责”维护状态，useXXX 去管理了。

         综上，灵活了，也好维护了